Perfect â€” this `runs.ts` is **solid** and you can build the header + `/api/status` on top of it cleanly. Hereâ€™s exactly what Iâ€™d change/add, and a checklist/action plan that reflects what you already have.

---

# What you already have (âœ…)

From the code you pasted:

âœ… File-backed run storage under `.simpleaide/runs/<runId>`
âœ… Strong metadata model (`RunMetadata`, status, timestamps, errorMessage)
âœ… Step folders with stable naming (`01_plan`, etc.)
âœ… Step status tracking with started/completed timestamps
âœ… Artifact save/read/list
âœ… Ability to â€œdelete steps fromâ€ to rerun from a checkpoint
âœ… Safe permissions (0700 dirs, 0600 files)

This is already 80% of a â€œworkflow/checkpointâ€ system.

---

# Whatâ€™s missing for the header + global status (and how to add it cleanly)

## A) Add 3 tiny read-only helpers to `RunsStorage`

These are safe because they donâ€™t change your storage format.

### 1) Active run count

â€œActiveâ€ = run status `running` or `pending` (you decide), or any step status is `running`.

```ts
async getActiveRunCount(): Promise<number> {
  const runs = await this.listRuns();
  return runs.filter(r => r.status === "running").length;
}
```

If you want â€œpendingâ€ to count too:

```ts
r.status === "running" || r.status === "pending"
```

### 2) Latest run summary

```ts
async getLatestRunSummary(): Promise<{
  id: string;
  status: RunStatus;
  startedAt: string;
  completedAt?: string;
} | null> {
  const runs = await this.listRuns();
  if (!runs.length) return null;
  const r = runs[0];
  return { id: r.id, status: r.status, startedAt: r.startedAt, completedAt: r.completedAt };
}
```

### 3) â€œBusyâ€ flag

```ts
async isBusy(): Promise<boolean> {
  return (await this.getActiveRunCount()) > 0;
}
```

> Why these matter: they allow the header to display â€œRun 1 â³â€ and a tooltip like â€œLast run failed 2m agoâ€ without loading every step/artifact.

---

## B) Important bug fix: `createStep()` doesnâ€™t update run status

Right now, `createRun()` sets `status: "pending"`, and unless something else updates it, the run might never show as â€œrunningâ€.

You can fix this with a single line after `run.metadata.stepCount = stepNumber`:

```ts
run.metadata.status = "running";
```

That will make active runs show correctly in the header.

---

# `/api/status` design (what your header should poll)

### One endpoint, tiny payload, frequent polling

Add:

```
GET /api/status
```

Return:

```ts
{
  env: "DEV" | "PROD",
  runs: {
    active: number,
    busy: boolean,
    last?: {
      id: string,
      status: RunStatus,
      startedAt: string,
      completedAt?: string,
      ageMs: number
    }
  }
}
```

Then you can expand later:

* vault locked/unlocked
* db connected/type/env/readOnly
* llm backends online/total
* apiUrl/apiPort

But start with **runs + env**.

---

# Header â€œglobal infoâ€ thatâ€™s actually worth showing

You asked what to put in the header: hereâ€™s the tight set that has the best signal:

### 1) `DEV ğŸŸ¢` / `PROD ğŸ”´`

Global profile. (Even if only DB uses it today.)

### 2) `Vault ğŸ”’` / `Vault ğŸ”“`

You already have secrets system; this is a top-tier signal.

### 3) `DB âœ…` / `DB OFF` + `RO`

Show `RO` in PROD.

### 4) `LLM 2/3`

Backends online/total (you already have AI Agents tab data).

### 5) `Run â³ 1`

Active run count + last run status tooltip.

All as tiny chips with tooltips, clickable to open the relevant tab.

---

# Checklist + action plan (SimpleAide)

## Checklist: confirm whatâ€™s implemented

### Runs

* [x] Runs persisted to `.simpleaide/runs`
* [x] Steps persisted as numbered folders
* [x] Artifacts saved per step
* [x] Can delete steps from checkpoint
* [ ] Run status reliably becomes `running` during execution (verify)
* [ ] Quick summary helpers exist (active count / last run)

### Header / Global Status

* [ ] `GET /api/status` exists
* [ ] Header chips exist (Env, Runs, Vault, DB, LLM)
* [ ] Clicking chips navigates correctly
* [ ] Polling is stable and lightweight (3â€“5s)

### Shell tab

* [ ] Real PTY via xterm.js + node-pty (if not already)

### Database tab

* [ ] Grid-first viewer/editor
* [ ] DEV editable, PROD read-only

---

## Action plan (in order)

### Phase 1 (fast, very visible)

1. Add `RunsStorage.getActiveRunCount/getLatestRunSummary/isBusy`
2. Fix run status update when a step starts (set run to `running`)
3. Implement `GET /api/status` (start with runs + env)
4. Add header chips for Env + Runs

### Phase 2

5. Expand `/api/status` to include:

   * vault lock + autoLockRemaining
   * db status
   * llm backend health
   * api url/port
6. Add header chips for Vault/DB/LLM

### Phase 3

7. Shell tab PTY (if needed)
8. Database grid baseline (SQLite + Postgres)

---

# What to tell your agent (copy/paste)

> In SimpleAide, extend `server/runs.ts` with read-only helpers: `getActiveRunCount()`, `getLatestRunSummary()`, and `isBusy()`. Also ensure run metadata status is set to `"running"` when the first step is created/executed (currently runs remain `"pending"` unless updated elsewhere).
> Add `GET /api/status` that returns `{ env, runs: { active, busy, last{ id,status,startedAt,completedAt,ageMs }}}` and later extend it for vault/db/llm health.
> Implement compact header status chips (Env, Runs, Vault, DB, LLM) with hover tooltips and click-to-navigate to the relevant tab. Keep it low-space and high-signal.

---

If you paste your `server/routes.ts` (or where your APIs are defined), I can tell you the **exact best place** to mount `/api/status` and how to compute â€œageMsâ€ correctly without timezone gotchas.
