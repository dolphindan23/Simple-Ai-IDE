Both. Here’s a **copy-paste ready** automated smoke runner + a **minimal manual curl checklist** you can drop into docs.

---

## 1) Automated CI smoke runner

Create: `script/smoke-ai-visibility.mjs`

```js
#!/usr/bin/env node
/**
 * Smoke test: AI visibility pipeline
 * - Starts server (npm run start:server or npm run dev -- depending on your setup)
 * - Opens SSE stream /api/ai/stream
 * - Triggers a run via POST /api/task/start
 * - Asserts required event types arrive:
 *   AGENT_STATUS(done), READ_FILE, WRITE_FILE, TOOL_CALL, PROPOSE_CHANGESET, STEP(with progress)
 *
 * Usage:
 *   node script/smoke-ai-visibility.mjs
 *
 * Env overrides:
 *   BASE_URL=http://localhost:5000
 *   START_CMD="npm run dev"
 *   REPO_PATH="/absolute/path/to/repo"
 *   MODE="implement"
 *   GOAL="..."
 *   TIMEOUT_MS=60000
 */

import { spawn } from "node:child_process";
import process from "node:process";
import { setTimeout as delay } from "node:timers/promises";

const BASE_URL = process.env.BASE_URL ?? "http://localhost:5000";
const START_CMD = process.env.START_CMD ?? "npm run dev"; // or "npm run start"
const REPO_PATH = process.env.REPO_PATH ?? process.cwd();
const MODE = process.env.MODE ?? "implement";
const GOAL =
  process.env.GOAL ??
  "SMOKE: make a trivial non-breaking change (e.g., update a comment) and run verification.";
const TIMEOUT_MS = Number(process.env.TIMEOUT_MS ?? 60000);

const REQUIRED = new Set([
  "READ_FILE",
  "WRITE_FILE",
  "TOOL_CALL",
  "PROPOSE_CHANGESET",
  "AGENT_STATUS_DONE",
  "STEP_PROGRESS",
]);

function log(...args) {
  console.log("[smoke]", ...args);
}

function fatal(msg) {
  console.error("[smoke] FAIL:", msg);
  process.exit(1);
}

async function fetchJson(url, options) {
  const res = await fetch(url, options);
  const text = await res.text();
  let json;
  try {
    json = text ? JSON.parse(text) : null;
  } catch {
    throw new Error(`Non-JSON response (${res.status}): ${text.slice(0, 300)}`);
  }
  if (!res.ok) throw new Error(`HTTP ${res.status}: ${JSON.stringify(json).slice(0, 500)}`);
  return json;
}

/**
 * Minimal SSE client using fetch + ReadableStream parsing.
 * Assumes server emits "data: ..." lines (JSON) and events separated by blank lines.
 */
async function connectSSE(url, onEvent) {
  const res = await fetch(url, { headers: { Accept: "text/event-stream" } });
  if (!res.ok || !res.body) throw new Error(`SSE connect failed: HTTP ${res.status}`);

  const reader = res.body.getReader();
  const decoder = new TextDecoder();
  let buf = "";

  (async () => {
    while (true) {
      const { value, done } = await reader.read();
      if (done) break;
      buf += decoder.decode(value, { stream: true });

      // Split on double newline (event delimiter)
      let idx;
      while ((idx = buf.indexOf("\n\n")) !== -1) {
        const chunk = buf.slice(0, idx);
        buf = buf.slice(idx + 2);

        // Parse lines, capture all data: lines (some servers chunk multiple)
        const dataLines = chunk
          .split("\n")
          .map((l) => l.trimEnd())
          .filter((l) => l.startsWith("data:"))
          .map((l) => l.replace(/^data:\s?/, ""));

        if (!dataLines.length) continue;

        const dataStr = dataLines.join("\n");
        try {
          const payload = JSON.parse(dataStr);
          onEvent(payload);
        } catch (e) {
          // Some servers send heartbeat as plain text. Ignore if non-JSON.
          // If you want strict mode, replace with fatal.
          log("Skipping non-JSON SSE data:", dataStr.slice(0, 200));
        }
      }
    }
  })().catch((e) => {
    fatal(`SSE stream error: ${e?.message ?? e}`);
  });

  return () => {
    try {
      reader.cancel();
    } catch {}
  };
}

function startServer() {
  log("Starting server:", START_CMD);
  const [cmd, ...args] = START_CMD.split(" ");
  const child = spawn(cmd, args, {
    shell: true,
    stdio: ["ignore", "pipe", "pipe"],
    env: process.env,
  });

  child.stdout.on("data", (d) => process.stdout.write(String(d)));
  child.stderr.on("data", (d) => process.stderr.write(String(d)));

  child.on("exit", (code) => {
    if (code !== 0) fatal(`Server exited early with code ${code}`);
  });

  return child;
}

async function waitForHealth() {
  const url = `${BASE_URL}/api/ai/agent-profiles`;
  const start = Date.now();
  while (Date.now() - start < 15000) {
    try {
      await fetchJson(url);
      return;
    } catch {
      await delay(300);
    }
  }
  fatal(`Server did not become ready in time (${url})`);
}

async function main() {
  const child = startServer();
  process.on("exit", () => child.kill("SIGTERM"));
  process.on("SIGINT", () => process.exit(1));
  process.on("SIGTERM", () => process.exit(1));

  await waitForHealth();
  log("Server is ready at", BASE_URL);

  // Track required signals
  const seen = new Set();
  let lastRunId = null;

  const stopSSE = await connectSSE(`${BASE_URL}/api/ai/stream`, (evt) => {
    // Expect shape roughly: { type, agent_id, message, data, run_id, ts } (your server may differ)
    const type = evt?.type ?? evt?.event_type ?? null;
    const agentStatus = evt?.data?.status ?? evt?.status ?? null;

    if (evt?.run_id) lastRunId = evt.run_id;

    if (type === "READ_FILE") seen.add("READ_FILE");
    if (type === "WRITE_FILE") seen.add("WRITE_FILE");
    if (type === "TOOL_CALL") seen.add("TOOL_CALL");
    if (type === "PROPOSE_CHANGESET") seen.add("PROPOSE_CHANGESET");

    if (type === "AGENT_STATUS" && agentStatus === "done") seen.add("AGENT_STATUS_DONE");

    // Step progress: either in evt.data or top-level fields
    const stepIndex = evt?.data?.step_index ?? evt?.step_index;
    const stepTotal = evt?.data?.step_total ?? evt?.step_total;
    if (type === "STEP" && Number.isFinite(stepIndex) && Number.isFinite(stepTotal)) {
      seen.add("STEP_PROGRESS");
    }

    // Optional debug
    // log("SSE:", JSON.stringify(evt).slice(0, 300));
  });

  // Kick off a run
  const startRes = await fetchJson(`${BASE_URL}/api/task/start`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ goal: GOAL, mode: MODE, repoPath: REPO_PATH }),
  });

  const runId = startRes?.runId ?? startRes?.data?.runId ?? lastRunId;
  log("Triggered run:", runId ?? "(unknown run id)");

  // Wait until required signals arrive or timeout
  const start = Date.now();
  while (Date.now() - start < TIMEOUT_MS) {
    let ok = true;
    for (const k of REQUIRED) {
      if (!seen.has(k)) {
        ok = false;
        break;
      }
    }
    if (ok) {
      stopSSE();
      log("PASS ✅ All required events observed:", [...REQUIRED].join(", "));
      process.exit(0);
    }
    await delay(250);
  }

  stopSSE();
  const missing = [...REQUIRED].filter((k) => !seen.has(k));
  fatal(`Timed out waiting for: ${missing.join(", ")} (seen: ${[...seen].join(", ")})`);
}

main().catch((e) => fatal(e?.message ?? String(e)));
```

### Add a package script (optional but nice)

In `package.json`:

```json
{
  "scripts": {
    "smoke:ai": "node script/smoke-ai-visibility.mjs"
  }
}
```

Run it:

```bash
npm run smoke:ai
```

CI example:

```bash
BASE_URL=http://localhost:5000 START_CMD="npm run dev" REPO_PATH="$PWD" npm run smoke:ai
```

---

## 2) Manual curl tests to add to docs (cheap + reliable)

Add a “Verify AI visibility” section:

### A) Check agent profiles (ensures schema + typing is right)

```bash
curl -s http://localhost:5000/api/ai/agent-profiles | jq .
```

You should see `model`, `max_context_tokens`, `default_temperature`, `tools_enabled`, `system_prompt`, `enabled`.

### B) SSE stream live (ensures real-time updates)

```bash
curl -N http://localhost:5000/api/ai/stream
```

Expected:

* init snapshot
* heartbeat
* live events during a run

### C) Trigger a run

```bash
curl -s -X POST http://localhost:5000/api/task/start \
  -H "Content-Type: application/json" \
  -d '{"goal":"SMOKE: trivial change + verify","mode":"implement","repoPath":"'"$PWD"'"}' | jq .
```

While it runs, in the SSE terminal confirm events appear:

* `AGENT_STATUS` with `status:"done"`
* `READ_FILE`
* `WRITE_FILE`
* `TOOL_CALL`
* `PROPOSE_CHANGESET`
* `STEP` with progress fields (`step_index/step_total`)

---

## 3) One extra “golden” runtime check

After the run completes, refresh the UI and confirm:

* timeline rehydrates from stored events
* roster shows correct final statuses (including done)
* model badges render (and don’t crash if model is null)

---

If you want, I can also tailor the smoke script to your **exact SSE payload shape** (some servers use `{event, data}` vs `{type, data}`), but the version above is already tolerant and should work with only minimal adjustments.
