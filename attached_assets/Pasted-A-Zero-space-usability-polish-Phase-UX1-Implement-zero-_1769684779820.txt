A) Zero-space usability polish (Phase UX1)

Implement “zero-space” usability upgrades:

File tree hover actions (only visible on hover): rename, delete, copy path; folders: new file/new folder.

Command palette (Cmd/Ctrl+K) with actions: open file, toggle output panel, switch workspace tabs, run Plan/Implement/Test/Review, open settings.

Editor typography defaults: JetBrains Mono (or fallback), fontSize=14, lineHeight=1.55, and UI text hierarchy (headers semibold).

Output panel: 3 states expanded/collapsed/hidden; draggable height resize; persist state and height.
Keep UI uncluttered: no new permanent panels.

B) AI Team panel polish (Phase UX2)

Convert AI Team output to “Action Cards” instead of chat bubbles:

Plan card, Patch card, Test card, Review card

Each card collapsible, shows model/backend + latency metadata

Patch card has inline mini-diff preview and a button for full diff view
Add a single toggle: Fast vs Accurate (routes to configured roles/models).

2) “Sheets for SQL” — what to build (and how to keep it simple)
The key concept

You’re not building pgAdmin. You’re building a table grid editor:

Select table → grid view → filter/sort → edit cells (dev only)

Optional “SQL mode” as a secondary view

Clean architecture (Phase DB1)

Implement Database tab as a “Data Grid”:

Support one DB engine initially (Postgres recommended).

Add environments: Development and Production. Production is read-only by default with a clear warning.

Add a left sidebar list of tables; clicking opens a grid.

Grid supports: pagination, sort, filter, inline edit, add row, delete row (dev only).

Changes are applied via parameterized queries and require primary key for updates/deletes.

Provide a “SQL view” toggle to run queries and show results in the same grid.

Persist DB connections per environment in Settings; credentials live in vault.

Tech choices (what makes it easy)

Frontend grid: use a mature data grid component (or a minimal table first, then upgrade).

Backend: create a small set of endpoints that abstract DB operations safely:

GET /api/db/:env/tables

GET /api/db/:env/schema/:table

GET /api/db/:env/rows/:table?limit=&offset=&sort=&filter=

POST /api/db/:env/rows/:table (insert)

PUT /api/db/:env/rows/:table/:pk (update)

DELETE /api/db/:env/rows/:table/:pk (delete)

POST /api/db/:env/query (read-only for prod; allow writes only in dev if you choose)

Important guardrail: production should default to read-only until explicitly unlocked each session.